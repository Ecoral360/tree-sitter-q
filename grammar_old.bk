/**
 * @file Q programming language
 * @author Mathis <ecomath360@gmail.com>
 * @license MIT
 */

/// <reference types="tree-sitter-cli/dsl" />
// @ts-check

module.exports = grammar({
  name: "q",

  rules: {
    // TODO: add the actual grammar rules
    source_file: ($) => repeat(choice($.declaration, $.definition)),
    declaration: ($) =>
      choice(
        $.unqualified_import,
        $.qualified_import,
        seq($.prefix, $.headers, ";"),
        seq(
          optional($.scope),
          "type",
          $.unqualified_identifier,
          optional(seq(":", $.identifier)),
          optional(seq("=", $.sections)),
          ";",
        ),
        seq(
          optional($.scope),
          "extern",
          "type",
          $.unqualified_identifier,
          optional(seq(":", $.identifier)),
          optional(seq("=", $.sections)),
          ";",
        ),
        seq(
          optional($.scope),
          "type",
          $.qualified_identifier,
          optional(seq("as", $.unqualified_identifier)),
          ";",
        ),
        seq(
          optional($.scope),
          "type",
          $.unqualified_identifier,
          "==",
          $.identifier,
          ";",
        ),
      ),

    unqualified_import: ($) =>
      seq(
        /import|include/,
        $.module_spec,
        repeat(seq(",", $.module_spec)),
        ";",
      ),
    qualified_import: ($) =>
      seq(
        "from",
        $.module_spec,
        /import|include/,
        optional($.symbol_specs),
        ";",
      ),

    module_spec: ($) =>
      choice(
        seq($.module_name, optional(seq("as", $.unqualified_identifier))),
        $.unqualified_identifier,
        $.string,
      ),
    module_name: ($) => choice($.unqualified_identifier, $.string),

    symbol_specs: ($) => seq($.symbol_spec, repeat(seq(",", $.symbol_spec))),

    symbol_spec: ($) =>
      choice(
        seq(
          $.unqualified_identifier,
          optional(seq("as", $.unqualified_identifier)),
        ),
        seq($.unqualified_opsym, optional(seq("as", $.unqualified_opsym))),
      ),

    prefix: ($) => choice($.scope, seq(optional($.scope), repeat1($.modifier))),

    scope: (_) => choice("private", "public"),
    modifier: (_) => choice("const", "special", "extern", "var", "virtual"),

    headers: ($) => seq($.header, repeat(seq(",", $.header))),

    header: ($) =>
      choice(
        seq($.unqualified_identifier, "=", $.expression),
        seq(
          $.unqualified_identifier,
          repeat(seq(optional("~"), $.variable_identifier)),
        ),
        seq(
          $.qualified_identifier,
          repeat(seq(optional("~"), $.variable_identifier)),
          optional(seq("as", $.unqualified_identifier)),
        ),
        seq(
          "(",
          $.unqualified_opsym,
          ")",
          repeat(seq(optional("~"), $.variable_identifier)),
          optional(seq("@", $.precedence)),
        ),
        seq(
          "(",
          $.qualified_opsym,
          ")",
          repeat(seq(optional("~"), $.variable_identifier)),
          optional(seq("@", $.precedence)),
          optional(seq("as", $.unqualified_opsym)),
        ),
      ),

    precedence: ($) => choice($.unsigned_number, seq("(", $.op, ")")),

    sections: ($) => seq($.section, repeat(seq("|", $.section))),

    section: ($) => seq(optional($.prefix), $.headers),

    definition: ($) =>
      choice(
        seq(
          $.expression,
          optional($.lqualifiers),
          "=",
          $.expression,
          optional($.qualifiers),
          ";",
          repeat(
            seq(
              optional($.lqualifiers),
              "=",
              $.expression,
              optional($.qualifiers),
              ";",
            ),
          ),
        ),
        seq(
          "def",
          $.expression,
          "=",
          $.expression,
          repeat(seq(",", $.expression, "=", $.expression)),
          ";",
        ),
        seq("undef", $.identifier, repeat(seq(",", $.identifier)), ";"),
      ),

    lqualifiers: ($) => seq(repeat1($.qualifier), ":"),

    qualifiers: ($) => repeat1($.qualifier),

    qualifier: ($) => choice($.condition, $.where_clause),

    condition: ($) => choice(seq("if", $.expression), "otherwise"),

    where_clause: ($) =>
      seq(
        "where",
        $.expression,
        "=",
        $.expression,
        repeat(seq(",", $.expression, "=", $.expression)),
      ),

    expression: ($) =>
      prec(
        10,
        choice(
          $.identifier,
          seq("var", $.unqualified_identifier),
          seq($.variable_identifier, ":", $.identifier),
          $.number,
          $.string,
          seq($.expression, $.expression),
          seq($.unary_op, $.expression),
          $._binop, //seq($.expression, $.binary_op, $.expression),
          seq(
            "if",
            $.expression,
            "then",
            $.expression,
            optional(seq("else", $.expression)),
          ),
          seq("\\", repeat1($.expression), ".", $.expression),
          seq(
            "(",
            optional(choice($.element_list, $.enumeration, $.comprehension)),
            ")",
          ),
          seq(
            "[",
            optional(choice($.element_list, $.enumeration, $.comprehension)),
            "]",
          ),
          seq(
            "{",
            optional(choice($.element_list, $.enumeration, $.comprehension)),
            "}",
          ),
          seq("(", $.op, ")"),
          seq("(", $.expression, $.binary_op, ")"),
          seq("(", $.binary_op, $.expression, ")"),
        ),
      ),

    _binop: ($) => {
      const bin_ops =
        /** @type {const} */
        ([
          [prec.left, 10, choice(".")],
          [prec.right, 9, choice("^", "!")],
          [prec.left, 8, choice()],
          [prec.left, 7, choice("*", "/", "div", "mod", "and", "and-then")],
          [prec.left, 6, choice("++", "+", "-", "or", "or-else")],
          [(_, op) => op, 0, choice("<", ">", "=", "<=", ">=", "<>", "==")],
          [prec.left, 4, choice("||")],
        ]);
      return choice(
        prec.right(
          5,
          seq(
            field("lhs", $.expression),
            choice("$"),
            field("rhs", $.expression),
          ),
        ),
        ...bin_ops.map(([f, precedence, op]) =>
          f(
            precedence,
            seq(
              field("lhs", $.expression),
              field("op", op),
              field("rhs", $.expression),
            ),
          ),
        ),
      );
    },

    element_list: ($) =>
      seq(
        $.expression_list,
        optional(choice(",", ";", seq("|", $.expression))),
      ),

    enumeration: ($) => seq($.expression_list, "..", optional($.expression)),

    comprehension: ($) => seq($.expression, ":", $.expression_list),

    expression_list: ($) =>
      seq(
        $.expression,
        choice(repeat(seq(",", $.expression)), repeat(seq(";", $.expression))),
      ),

    identifier: ($) => choice($.unqualified_identifier, $.qualified_identifier),

    qualified_identifier: ($) =>
      seq($.module_identifier, "::", $.unqualified_identifier),
    unqualified_identifier: ($) =>
      choice($.variable_identifier, $.function_identifier, $.type_identifier),

    module_identifier: ($) =>
      seq($._letter, repeat(choice($._letter, $._digitsym))),
    type_identifier: ($) => seq($._letter, repeat(choice($._letter, $._digitsym))),
    variable_identifier: ($) =>
      choice(
        "_",
        seq($._uppercase_letter, repeat(choice($._letter, $._digitsym))),
      ),

    function_identifier: ($) =>
      seq($._lowercase_letter, repeat(choice($._letter, $._digitsym))),

    op: ($) => choice($.unary_op, $.binary_op),

    unary_op: ($) => $.opsym,
    binary_op: ($) => choice($.opsym, seq("and", "then"), seq("or", "else")),

    opsym: ($) => choice($.unqualified_opsym, $.qualified_opsym),

    qualified_opsym: ($) => seq($.module_identifier, "::", $.unqualified_opsym),
    unqualified_opsym: ($) =>
      choice($.function_identifier, repeat1($._punctsym)),

    number: ($) => seq(optional("-"), $.unsigned_number),
    unsigned_number: ($) =>
      choice(
        seq(/0x/i, $._hexdigitseq),
        seq("0", $._octdigitseq),
        seq(
          $._digitseq,
          optional(seq(".", optional($._digitseq))),
          optional($.scalefact),
        ),
        seq(optional($._digitseq), ".", $._digitseq, optional($.scalefact)),
      ),

    _digitseq: ($) => repeat1($._digit),
    _octdigitseq: ($) => repeat1($._octdigit),
    _hexdigitseq: ($) => repeat1($._hexdigit),

    scalefact: ($) => seq(/e/i, optional("-"), $._digitseq),

    string: ($) => seq('"', repeat($._char), '"'),

    _letter: ($) => choice($._lowercase_letter, $._uppercase_letter),
    _lowercase_letter: (_) => /[a..z]|\p{Lowercase_Letter}/u,
    _uppercase_letter: (_) => /[A..Z]|\p{Uppercase_Letter}/u,

    _digitsym: (_) => /[0..9]|\p{digit}/u,
    _punctsym: (_) => /\p{P}/u,

    _digit: (_) => /[0..9]/,
    _octdigit: (_) => /[0..7]/,
    _hexdigit: (_) => /[0..9a..fA..F]/,

    _char: (_) => /[^\n"]/,
  },
});
